opts_chunk$set(comment="  ",
collapse=TRUE,
#echo=FALSE,
fig.asp=1/gr,
dev="png"
)
options(digits=3)
#  now, this could be done analytically pretty easily, but
# I want to try some things out in r so
# this is my caveat that I know I'm not doing this the most
# efficient way
Ncard = 48 # number of cards in pinocle deck
suits = c('heart', 'diamond', 'club', 'spade')
values = c('9', '10', 'J', 'Q', 'K', 'A')
Ncopy = 2
cards = list()
counter = 0
for (suit in suits){
for (value in values){
for (i in range(0, Ncopy)){
# neither option seems to work
cards = append(cards, list("s"=suit, "v"=value))
#      cards[counter] = list("s"=suit, "v"=value)
#      counter = counter + 1
}
}
}
#not sure why this returns null, must be missing some nuance of nested lists?
print(cards[20]$s)
#  now, this could be done analytically pretty easily, but
# I want to try some things out in r so
# this is my caveat that I know I'm not doing this the most
# efficient way
Ncard = 48 # number of cards in pinocle deck
suits = c('heart', 'diamond', 'club', 'spade')
values = c('9', '10', 'J', 'Q', 'K', 'A')
Ncopy = 2
cards = list()
cards = vector(mode='list', length = Ncard)
counter = 0
for (suit in suits){
for (value in values){
for (i in range(0, Ncopy)){
# neither option seems to work
cards = append(cards, list("s"=suit, "v"=value))
#      cards[counter] = list("s"=suit, "v"=value)
#      counter = counter + 1
}
}
}
#not sure why this returns null, must be missing some nuance of nested lists?
print(cards[20]$s)
#  now, this could be done analytically pretty easily, but
# I want to try some things out in r so
# this is my caveat that I know I'm not doing this the most
# efficient way
Ncard = 48 # number of cards in pinocle deck
suits = c('heart', 'diamond', 'club', 'spade')
values = c('9', '10', 'J', 'Q', 'K', 'A')
Ncopy = 2
cards = list()
cards = vector(mode='list', length = Ncard)
counter = 0
for (suit in suits){
for (value in values){
for (i in range(0, Ncopy)){
# neither option seems to work
# cards = append(cards, list("s"=suit, "v"=value))
cards[[counter]] = list("s"=suit, "v"=value)
#      counter = counter + 1
}
}
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
ppD = function(tr, tpr, fpr, prior) {
# adpated from DBDA pg 104
#calculate marginal probs
posTest = tpr*prior + fpr*(1-prior)
negTest = (1-tpr)*prior + (1-fpr)*(1-prior)
if (tr == 1){
# test is pos
post = tpr*prior / posTest
}
else {
# test is neg
post = fpr*prior/negTest
}
return(post)
}
#given values
tpr = 0.99
fpr = 0.05
prior = 0.001
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
print(df)
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr, fpr, prior){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
df$results = apply(df, c(1,2), composite_ppD)
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
df$results = apply(df, c(1,2), composite_ppD)
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(i)
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(i[0])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(i, df$tes1t[i])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(i, df$tesst[i])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$tesst[i])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test[i])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test[[i]])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1)
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1[0])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1[i])
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1[i][0])
results[i[0]] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1[i])
results[i[0]] = composite_ppD(df$test1[i][0], df$test2[i][0])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
print(df$test1[[i]])
results[i[0]] = composite_ppD(df$test1[i][0], df$test2[i][0])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){}
results[i] = composite_ppD(df$test1[i][0], df$test2[i][0])
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){}
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#assume first test is positive, if first test is neg prob not testing twice
first_test = ppD(1, 0.99, 0.05, 0.001)
second_test = ppD(0, 0.99, 0.05, first_test)
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
#actually write a function to wrap both
composite_ppD = function(tr1, tr2, tpr=0.99, fpr=0.05, prior=0.001){
first_result = ppD(tr1, tpr, fpr, prior)
second_result = ppD(tr2, tpr, fpr, first_result)
return(second_result)
}
# just having fun with dataframes
df = data.frame('test1'=c(0,0,1,1), 'test2'=c(0,1,0,1))
# didnt work
#df$results = apply(df, c(1,2), composite_ppD)
results = vector(length = 4)
# not sure how to iterate through a double list, this can be done in python like:
#result = [function(a,b) for a,b in zip(list_a, list_b)]
# but brute force works as well
for (i in c(0,1,2,3)){
results[i] = composite_ppD(df$test1[i], df$test2[i])
}
